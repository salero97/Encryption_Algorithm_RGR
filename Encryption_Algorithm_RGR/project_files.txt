=== Encryption_Algorithm_RGR/include/cipher_plugin.h ===
#ifndef CIPHER_PLUGIN_H
#define CIPHER_PLUGIN_H

#include <string>
#include <vector>
#include <cstdint>
#include <dlfcn.h>

// Типы для указателей на функции из API
typedef const char* (*GetCipherName_t)();
typedef bool (*ValidateKey_t)(const std::string &);
typedef void (*EncryptData_t)(const uint8_t *, uint8_t *, size_t, const std::string &);
typedef void (*DecryptData_t)(const uint8_t *, uint8_t *, size_t, const std::string &);

// Структура для хранения информации о загруженном плагине
struct CipherPlugin {
    void *handle;  // Указатель на загруженную .so библиотеку (из dlopen)
    std::string name;  // Название алгоритма
    
    // Указатели на функции из API
    GetCipherName_t getCipherName;
    ValidateKey_t validateKey;
    EncryptData_t encryptData;
    DecryptData_t decryptData;
};

// Глобальная коллекция всех загруженных плагинов
extern std::vector<CipherPlugin> loadedCiphers;

#endif


=== Encryption_Algorithm_RGR/include/bigram/bigram_cipher_interface.h ===
#ifndef BIGRAM_CIPHER_INTERFACE_H
#define BIGRAM_CIPHER_INTERFACE_H

void runBigramCipher();

#endif

=== Encryption_Algorithm_RGR/include/bigram/bigram_cipher.h ===
#ifndef BIGRAM_CIPHER_H
#define BIGRAM_CIPHER_H

#include <vector>
#include <string>
#include <map>
#include <utility>
#include <cstdint>

using namespace std;

class BigramCipher {
private:
    vector<vector<int>> matrix;
    map<int, pair<int, int>> positions;
    string key;
    
    void createMatrix();
    void permuteMatrix();
    void findPositions();
    vector<pair<int, int>> makeBigrams(const vector<int>& codes);
    
    pair<int, int> encryptBigram(int a, int b);
    pair<int, int> decryptBigram(int a, int b);
    
public:
    BigramCipher(const string& key);
    
    vector<int> encrypt(const vector<int>& codes);
    vector<int> decrypt(const vector<int>& codes);
    
    vector<uint8_t> encryptBytes(const vector<uint8_t>& data);
    vector<uint8_t> decryptBytes(const vector<uint8_t>& data);
    
    string encryptText(const string& text);
    string decryptText(const string& text);
    
    static vector<uint8_t> processBytes(const vector<uint8_t>& data, const string& key, bool encrypt);
    static string processText(const string& text, const string& key, bool encrypt);
};

#endif

=== Encryption_Algorithm_RGR/include/utils.h ===
#ifndef UTILS_H
#define UTILS_H

#include <vector>
#include <string>
#include <initializer_list>
#include <filesystem>
#include <chrono>
#include <map>
#include <utility>

using namespace std;
namespace fs = filesystem;


void clearInputBuffer();
int getChoice(const string& prompt, const initializer_list<int>& options);
int getIntegerInput(const string& prompt, int min, int max);
string getLine(const string& prompt, bool maskInput = false);
bool isDigits(const string& str);
void initLocale();
string generateRandomKey(int length);

vector<unsigned char> readFile(const string& filename);
void writeFile(const string& filename, const vector<unsigned char>& data);
vector<string> getFilesInCurrentDir();
string getFileType(const std::string& filename);
void createLogFile(const string& outputPath, const string& cipherName,
                 const string& operation, const string& key,
                 const string& inputFile, const string& outputFile);

vector<string> getFilesInCurrentDir();
void createLogFile(const string& outputPath, const string& cipherName,
                 const string& operation, const string& key,
                 const string& inputFile, const string& outputFile);


int randomInt(int min, int max);


void printHex(const vector<unsigned char>& data);
void printTextRepresentation(const vector<unsigned char>& data);


vector<unsigned char> hexToBytes(const string& hex);
void saveKeyToFile(const string& filename, const map<pair<unsigned char, unsigned char>, unsigned char>& key);
map<pair<unsigned char, unsigned char>, unsigned char> loadKeyFromFile(const string& filename);
string bytesToHex(const vector<unsigned char>& data);


bool isImageFile(const std::string& filename);
std::string getFileExtension(const std::string& filename);

#endif

=== Encryption_Algorithm_RGR/include/vigenere/vigenere_cipher.h ===
#ifndef VIGENERE_CIPHER_H
#define VIGENERE_CIPHER_H

#include <vector>
#include <string>
#include "utils.h"

using namespace std;

inline void validateKey(const string& key) {
    if (key.empty()) {
        throw invalid_argument("Ключ не может быть пустым");
    }
}

vector<unsigned char> vigenereEncrypt(const vector<unsigned char>& data, const string& key);
vector<unsigned char> vigenereDecrypt(const vector<unsigned char>& data, const string& key);
string generateVigenereKey(int length);

#endif

=== Encryption_Algorithm_RGR/include/vigenere/vigenere_cipher_interface.h ===
#ifndef VIGENERE_CIPHER_INTERFACE_H
#define VIGENERE_CIPHER_INTERFACE_H

#include <vector>
#include <string>


void runVigenereCipher();

#endif 


=== Encryption_Algorithm_RGR/include/great/great_cipher.h ===
#ifndef GREAT_CIPHER_H
#define GREAT_CIPHER_H

#include <vector>
#include <string>
#include <map>
#include <cstdint>

using namespace std;

class GreatCipher {
private:
    map<uint16_t, vector<uint8_t>> encryptionTable;
    map<uint8_t, vector<uint16_t>> decryptionTable;
    vector<uint16_t> homophoneSequence;
    uint32_t keySeed;
    
    void createTables();
    uint16_t getNextCode(size_t position);
    
public:
    GreatCipher(uint32_t seed);
    GreatCipher(const string& key);
    
    vector<uint8_t> encrypt(const vector<uint8_t>& data);
    vector<uint8_t> decrypt(const vector<uint8_t>& data);
    
    string encryptText(const string& text);
    string decryptText(const string& text);
    
    static vector<uint8_t> processBytes(const vector<uint8_t>& data, const string& key, bool encrypt);
    static string processText(const string& text, const string& key, bool encrypt);
};

#endif

=== Encryption_Algorithm_RGR/include/great/great_cipher_interface.h ===
#ifndef GREAT_CIPHER_INTERFACE_H
#define GREAT_CIPHER_INTERFACE_H

#include <vector>
#include <string>

void runGreatCipher();

#endif 

=== Encryption_Algorithm_RGR/include/funcs.h ===
#ifndef FUNCS_H
#define FUNCS_H

#include <string>
#include <vector>

bool LoadCipher(const std::string &libraryPath);

void UnloadAllCiphers();

void ProcessTextEncryption();

void ProcessFileEncryption();

void ShowKeyGenerator();

std::string getUserNameForCipher(const std::string &internalName);

#endif


=== Encryption_Algorithm_RGR/include/api.h ===
#ifndef API_H
#define API_H

#include <cstdint>
#include <string>
#include <vector>

// Все алгоритмы ДОЛЖНЫ экспортировать эти функции через extern "C"

extern "C" {
    // Возврат названия алгоритма шифрования
    const char* GetCipherName();
    
    // Проверка корректности ключа
    bool ValidateKey(const std::string &key);
    
    // Шифрование данных
    // inputData  - исходные данные
    // outputData - буфер для результата (размер >= inputSize)
    // dataSize   - размер данных в байтах
    // key        - ключ шифрования
    void EncryptData(const uint8_t *inputData, uint8_t *outputData, 
                    size_t dataSize, const std::string &key);
    
    // Дешифрование данных (аналогично EncryptData)
    void DecryptData(const uint8_t *inputData, uint8_t *outputData, 
                    size_t dataSize, const std::string &key);
}

#endif


=== Encryption_Algorithm_RGR/Encryption_Algorithm_RGR.sh ===
#!/bin/bash

# Скрипт для запуска программы с правильными переменными окружения

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
APP_PATH="$SCRIPT_DIR/bin/Encryption_Algorithm_RGR"
LIBS_PATH="$SCRIPT_DIR/libs"

# Устанавливаем LD_LIBRARY_PATH для поиска .so файлов
export LD_LIBRARY_PATH="$LIBS_PATH:$LD_LIBRARY_PATH"

# Проверяем существование программы
if [ ! -f "$APP_PATH" ]; then
    echo "❌ Ошибка: Программа не найдена в $APP_PATH"
    echo "Пожалуйста, сначала скомпилируйте проект: make"
    exit 1
fi

# Проверяем существование папки libs
if [ ! -d "$LIBS_PATH" ]; then
    echo "❌ Ошибка: Папка libs/ не найдена"
    exit 1
fi

# Запускаем программу
exec "$APP_PATH" "$@"


=== Encryption_Algorithm_RGR/Makefile ===
CXX := g++
CXXFLAGS := -std=c++17 -Wall -Wextra -fPIC -O3
LDFLAGS_LIB := -shared
LDFLAGS_MAIN := -ldl

BIN_DIR := bin
LIBS_DIR := libs
OBJ_DIR := obj
SRC_DIR := src
INCLUDE_DIR := include

MAIN_SOURCES := \
	src/main.cpp \
	src/utils.cpp \
	src/funcs.cpp \
	src/vigenere/vigenere_cipher.cpp \
	src/vigenere/vigenere_cipher_interface.cpp \
	src/great/great_cipher.cpp \
	src/great/great_cipher_interface.cpp \
	src/bigram/bigram_cipher.cpp \
	src/bigram/bigram_cipher_interface.cpp

MAIN_OBJECTS := $(patsubst src/%.cpp,$(OBJ_DIR)/%.o,$(MAIN_SOURCES))

VIGENERE_SOURCES := \
	src/vigenere/vigenere_cipher.cpp \
	src/vigenere/vigenere_wrapper.cpp

VIGENERE_OBJECTS := $(patsubst src/%.cpp,$(OBJ_DIR)/%.o,$(VIGENERE_SOURCES))

GREAT_SOURCES := \
	src/great/great_cipher.cpp \
	src/great/great_wrapper.cpp

GREAT_OBJECTS := $(patsubst src/%.cpp,$(OBJ_DIR)/%.o,$(GREAT_SOURCES))

BIGRAM_SOURCES := \
	src/bigram/bigram_cipher.cpp \
	src/bigram/bigram_wrapper.cpp

BIGRAM_OBJECTS := $(patsubst src/%.cpp,$(OBJ_DIR)/%.o,$(BIGRAM_SOURCES))


.PHONY: all clean create_dirs

all: create_dirs $(BIN_DIR)/Encryption_Algorithm_RGR $(LIBS_DIR)/libvigenere.so $(LIBS_DIR)/libgreat.so $(LIBS_DIR)/libbigram.so
	@echo "✓ Сборка завершена!"

create_dirs:
	@mkdir -p $(BIN_DIR) $(LIBS_DIR) $(OBJ_DIR)/vigenere $(OBJ_DIR)/great $(OBJ_DIR)/bigram

$(BIN_DIR)/Encryption_Algorithm_RGR: $(MAIN_OBJECTS)
	@mkdir -p $(@D)
	$(CXX) $(CXXFLAGS) $^ -o $@ $(LDFLAGS_MAIN)
	@echo "✓ Главная программа собрана"

$(LIBS_DIR)/libvigenere.so: $(VIGENERE_OBJECTS)
	$(CXX) $(LDFLAGS_LIB) $^ -o $@
	@echo "✓ libvigenere.so создана"

$(LIBS_DIR)/libgreat.so: $(GREAT_OBJECTS)
	$(CXX) $(LDFLAGS_LIB) $^ -o $@
	@echo "✓ libgreat.so создана"

$(LIBS_DIR)/libbigram.so: $(BIGRAM_OBJECTS)
	$(CXX) $(LDFLAGS_LIB) $^ -o $@
	@echo "✓ libbigram.so создана"

$(OBJ_DIR)/%.o: $(SRC_DIR)/%.cpp
	@mkdir -p $(@D)
	$(CXX) $(CXXFLAGS) -I$(INCLUDE_DIR) -c $< -o $@

clean:
	@rm -rf $(OBJ_DIR) $(BIN_DIR) $(LIBS_DIR)
	@echo "✓ Очистка завершена"

install: all
	@sudo install -m 755 $(BIN_DIR)/Encryption_Algorithm_RGR /usr/local/bin/
	@echo "✓ Установка завершена"


=== Encryption_Algorithm_RGR/src/bigram/bigram_cipher_interface.cpp ===
#include "bigram/bigram_cipher_interface.h"
#include "bigram/bigram_cipher.h"
#include "utils.h"
#include <iostream>
#include <sstream>
#include <iomanip>
#include <filesystem>
#include <algorithm>

using namespace std;
namespace fs = filesystem;

void printBigramResult(const vector<uint8_t>& data, bool isEncrypted, bool isFile = false) {
    if (isFile) {
        cout << "Результат (первые 16 байт в hex): ";
        for (size_t i = 0; i < min(data.size(), static_cast<size_t>(16)); ++i) {
            cout << hex << setw(2) << setfill('0') << static_cast<int>(data[i]) << " ";
        }
        cout << dec << endl;
    } else {
        if (isEncrypted) {
            cout << "Результат (hex): ";
            for (uint8_t byte : data) {
                cout << hex << setw(2) << setfill('0') << static_cast<int>(byte) << " ";
            }
            cout << dec << endl << "Текстовое представление: ";
            
            string text(data.begin(), data.end());
            for (char c : text) {
                if (c >= 32 && c < 127) {
                    cout << c;
                } else {
                    cout << ".";
                }
            }
            cout << endl;
        } else {
            // ТОЛЬКО для дешифрования - показываем только текст
            string resultText(data.begin(), data.end());
            cout << "Расшифрованный текст: " << resultText << endl;
        }
    }
}

void runBigramCipher() {
    try {
        cout << "=== Биграммный шифр Тритемия ===" << endl;
        cout << "Классический шифр с матрицей 16x16" << endl;

        bool encrypt = getChoice("Выберите:\n1. Шифровать\n2. Дешифровать\nВаш выбор: ", {1, 2}) == 1;

        // ВВОД КЛЮЧА
        string key;
        int keyChoice = getChoice("Ключ:\n1. Ввести\n2. Сгенерировать\nВаш выбор: ", {1, 2});
        
        if (keyChoice == 2) {
            int length = getIntegerInput("Длина ключа (1-20): ", 1, 20);
            key = generateRandomKey(length);
            cout << "Сгенерированный ключ: " << key << endl;
        } else {
            key = getLine("Введите ключ: ", false);
            if (key.empty()) {
                cout << "Ошибка: Ключ не может быть пустым" << endl;
                return;
            }
        }

        int sourceChoice = getChoice("Данные:\n1. Ввести текст\n2. Работа с файлом\nВаш выбор: ", {1, 2});

        if (sourceChoice == 2) {
            // Файловая работа
            cout << "\nФайлы в текущей директории:\n";
            vector<string> files = getFilesInCurrentDir();
            for (const auto& file : files) {
                cout << "- " << file << endl;
            }
            cout << endl;

            string inputFile = getLine("Введите имя файла или полный путь: ", false);

            // ПРЕДУПРЕЖДЕНИЕ ДЛЯ ИЗОБРАЖЕНИЙ
            if (encrypt && isImageFile(inputFile)) {
                cout << "⚠️  ВНИМАНИЕ: Выбран файл изображения.\n";
                cout << "Шифрование может сделать изображение непригодным для просмотра.\n";
                int continueChoice = getChoice("Продолжить? (1-Да, 2-Нет): ", {1, 2});
                if (continueChoice != 1) {
                    cout << "Операция отменена.\n";
                    return;
                }
            }

            string outputPath = getLine("Куда сохранить результат? (оставьте пустым для сохранения рядом): ", false);

            vector<unsigned char> inputData = readFile(inputFile);
            vector<uint8_t> inputBytes(inputData.begin(), inputData.end());
            
            vector<uint8_t> outputBytes;
            if (encrypt) {
                outputBytes = BigramCipher::processBytes(inputBytes, key, true);
            } else {
                outputBytes = BigramCipher::processBytes(inputBytes, key, false);
            }

            vector<unsigned char> outputData(outputBytes.begin(), outputBytes.end());

            if (outputPath.empty()) {
                fs::path p = fs::path(inputFile);
                outputPath = p.stem().string() + (encrypt ? "_bigram_enc" : "_bigram_dec") + p.extension().string();
            }

            writeFile(outputPath, outputData);
            cout << "Файл будет сохранен по пути: " << fs::absolute(outputPath) << endl;
            printBigramResult(outputBytes, encrypt, true);
            
            createLogFile(outputPath, "Bigram Cipher (Tritemius)", encrypt ? "cipher" : "decipher", 
                         key, inputFile, outputPath);
        } else {
            // Текстовый ввод
            if (encrypt) {
                string text = getLine("Введите текст: ", false);
                string result = BigramCipher::processText(text, key, true);
                vector<uint8_t> resultBytes(result.begin(), result.end());
                printBigramResult(resultBytes, true);
            } else {
                string hexInput = getLine("Введите hex: ", false);
                vector<unsigned char> data = hexToBytes(hexInput);
                vector<uint8_t> bytes(data.begin(), data.end());
                vector<uint8_t> resultBytes = BigramCipher::processBytes(bytes, key, false);
                printBigramResult(resultBytes, false);
            }
        }
    } catch (const exception& e) {
        cerr << "Ошибка: " << e.what() << endl;
    }
    
    cin.clear();
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
}

=== Encryption_Algorithm_RGR/src/bigram/bigram_wrapper.cpp ===
#include "bigram/bigram_cipher.h"
#include "api.h"
#include <cstring>

extern "C" {
    
    const char* GetCipherName() {
        return "Bigram Cipher (Tritemius)";
    }
    
    bool ValidateKey(const std::string &key) {
        return !key.empty() && key.length() <= 256;
    }
    
    void EncryptData(const uint8_t *inputData, uint8_t *outputData, 
                    size_t dataSize, const std::string &key) {
        if (!inputData || !outputData || dataSize == 0) return;
        
        std::vector<uint8_t> input(inputData, inputData + dataSize);
        std::vector<uint8_t> encrypted = BigramCipher::processBytes(input, key, true);
        
        std::memcpy(outputData, encrypted.data(), encrypted.size());
    }
    
    void DecryptData(const uint8_t *inputData, uint8_t *outputData, 
                    size_t dataSize, const std::string &key) {
        if (!inputData || !outputData || dataSize == 0) return;
        
        std::vector<uint8_t> input(inputData, inputData + dataSize);
        std::vector<uint8_t> decrypted = BigramCipher::processBytes(input, key, false);
        
        std::memcpy(outputData, decrypted.data(), decrypted.size());
    }
}


=== Encryption_Algorithm_RGR/src/bigram/bigram_cipher.cpp ===
#include "bigram/bigram_cipher.h"
#include <algorithm>
#include <stdexcept>
#include <cstdint>
#include <functional>
#include <random>
#include <numeric>

using namespace std;

BigramCipher::BigramCipher(const string& key) : key(key) {
    createMatrix();
    permuteMatrix();
    findPositions();
}

void BigramCipher::createMatrix() {
    // Создаем базовую матрицу 16x16
    matrix.resize(16, vector<int>(16));
    
    int value = 0;
    for (int i = 0; i < 16; i++) {
        for (int j = 0; j < 16; j++) {
            matrix[i][j] = value++;
        }
    }
}

void BigramCipher::permuteMatrix() {
    if (key.empty()) return;
    
    // Используем ключ для инициализации генератора
    size_t seed = 0;
    for (char c : key) {
        seed = seed * 31 + static_cast<size_t>(c);
    }
    
    mt19937 generator(seed);
    
    // Создаем случайную перестановку для всей матрицы
    vector<int> indices(256);
    iota(indices.begin(), indices.end(), 0);
    shuffle(indices.begin(), indices.end(), generator);
    
    // Заполняем матрицу в случайном порядке
    int index = 0;
    for (int i = 0; i < 16; i++) {
        for (int j = 0; j < 16; j++) {
            matrix[i][j] = indices[index++];
        }
    }
}

void BigramCipher::findPositions() {
    positions.clear();
    for (int i = 0; i < 16; i++) {
        for (int j = 0; j < 16; j++) {
            positions[matrix[i][j]] = make_pair(i, j);
        }
    }
}

vector<pair<int, int>> BigramCipher::makeBigrams(const vector<int>& codes) {
    vector<pair<int, int>> bigrams;
    
    for (size_t i = 0; i < codes.size(); i += 2) {
        int first = codes[i];
        int second;
        
        if (i + 1 < codes.size()) {
            second = codes[i + 1];
            // Если одинаковые символы, добавляем разделитель
            if (first == second) {
                second = 0xFF; // Специальный символ-разделитель
                i--; // Отступаем, чтобы не пропустить символ
            }
        } else {
            // Если нечетное количество, добавляем заполнитель
            second = 0xFF;
        }
        
        bigrams.push_back(make_pair(first, second));
    }
    
    return bigrams;
}

pair<int, int> BigramCipher::encryptBigram(int a, int b) {
    // Если символы не найдены в матрице, возвращаем как есть
    if (positions.find(a) == positions.end() || positions.find(b) == positions.end()) {
        return make_pair(a, b);
    }
    
    auto posA = positions[a];
    auto posB = positions[b];
    
    int rowA = posA.first, colA = posA.second;
    int rowB = posB.first, colB = posB.second;
    
    if (rowA == rowB) {
        // Одна строка - сдвигаем вправо
        colA = (colA + 1) % 16;
        colB = (colB + 1) % 16;
    } else if (colA == colB) {
        // Один столбец - сдвигаем вниз
        rowA = (rowA + 1) % 16;
        rowB = (rowB + 1) % 16;
    } else {
        // Прямоугольник - меняем столбцы
        swap(colA, colB);
    }
    
    return make_pair(matrix[rowA][colA], matrix[rowB][colB]);
}

pair<int, int> BigramCipher::decryptBigram(int a, int b) {
    if (positions.find(a) == positions.end() || positions.find(b) == positions.end()) {
        return make_pair(a, b);
    }
    
    auto posA = positions[a];
    auto posB = positions[b];
    
    int rowA = posA.first, colA = posA.second;
    int rowB = posB.first, colB = posB.second;
    
    if (rowA == rowB) {
        // Одна строка - сдвигаем влево
        colA = (colA - 1 + 16) % 16;
        colB = (colB - 1 + 16) % 16;
    } else if (colA == colB) {
        // Один столбец - сдвигаем вверх
        rowA = (rowA - 1 + 16) % 16;
        rowB = (rowB - 1 + 16) % 16;
    } else {
        // Прямоугольник - меняем столбцы
        swap(colA, colB);
    }
    
    return make_pair(matrix[rowA][colA], matrix[rowB][colB]);
}

vector<int> BigramCipher::encrypt(const vector<int>& codes) {
    if (codes.empty()) return {};
    
    auto bigrams = makeBigrams(codes);
    vector<int> result;
    
    for (const auto& bigram : bigrams) {
        auto encrypted = encryptBigram(bigram.first, bigram.second);
        result.push_back(encrypted.first);
        result.push_back(encrypted.second);
    }
    
    return result;
}

vector<int> BigramCipher::decrypt(const vector<int>& codes) {
    if (codes.empty() || codes.size() % 2 != 0) return {};
    
    vector<int> result;
    
    for (size_t i = 0; i < codes.size(); i += 2) {
        auto decrypted = decryptBigram(codes[i], codes[i + 1]);
        result.push_back(decrypted.first);
        result.push_back(decrypted.second);
    }
    
    // Убираем заполнители
    result.erase(remove(result.begin(), result.end(), 0xFF), result.end());
    
    return result;
}

vector<uint8_t> BigramCipher::encryptBytes(const vector<uint8_t>& data) {
    vector<int> codes;
    for (uint8_t byte : data) {
        codes.push_back(static_cast<int>(byte));
    }
    
    vector<int> encryptedCodes = encrypt(codes);
    
    vector<uint8_t> result;
    for (int code : encryptedCodes) {
        result.push_back(static_cast<uint8_t>(code));
    }
    
    return result;
}

vector<uint8_t> BigramCipher::decryptBytes(const vector<uint8_t>& data) {
    vector<int> codes;
    for (uint8_t byte : data) {
        codes.push_back(static_cast<int>(byte));
    }
    
    vector<int> decryptedCodes = decrypt(codes);
    
    vector<uint8_t> result;
    for (int code : decryptedCodes) {
        result.push_back(static_cast<uint8_t>(code));
    }
    
    return result;
}

string BigramCipher::encryptText(const string& text) {
    vector<uint8_t> inputBytes(text.begin(), text.end());
    vector<uint8_t> encryptedBytes = encryptBytes(inputBytes);
    return string(encryptedBytes.begin(), encryptedBytes.end());
}

string BigramCipher::decryptText(const string& text) {
    vector<uint8_t> inputBytes(text.begin(), text.end());
    vector<uint8_t> decryptedBytes = decryptBytes(inputBytes);
    return string(decryptedBytes.begin(), decryptedBytes.end());
}

vector<uint8_t> BigramCipher::processBytes(const vector<uint8_t>& data, const string& key, bool encrypt) {
    BigramCipher cipher(key);
    
    if (encrypt) {
        return cipher.encryptBytes(data);
    } else {
        return cipher.decryptBytes(data);
    }
}

string BigramCipher::processText(const string& text, const string& key, bool encrypt) {
    BigramCipher cipher(key);
    
    if (encrypt) {
        return cipher.encryptText(text);
    } else {
        return cipher.decryptText(text);
    }
}

=== Encryption_Algorithm_RGR/src/funcs.cpp ===
#include "funcs.h"
#include "cipher_plugin.h"
#include "utils.h"
#include "api.h"
#include <iostream>
#include <dlfcn.h>
#include <filesystem>
#include <iomanip>

using namespace std;
namespace fs = filesystem;

vector<CipherPlugin> loadedCiphers;

string getUserNameForCipher(const string &internalName) {
    if (internalName == "Vigenere Cipher") {
        return "Шифр Виженера";
    } else if (internalName == "Great Cipher (Louis XIV)") {
        return "Великий шифр (Louis XIV)";
    } else if (internalName == "Bigram Cipher (Tritemius)") {
        return "Биграммный шифр Тритемия";
    }
    return internalName;
}

bool LoadCipher(const string &libraryPath) {
    try {
        if (!fs::exists(libraryPath)) {
            cerr << "Ошибка загрузки библиотеки >> " << libraryPath << endl;
            return false;
        }

        void *handle = dlopen(libraryPath.c_str(), RTLD_LAZY);
        if (!handle) {
            cerr << "Ошибка загрузки библиотеки >> " << libraryPath << endl;
            cerr << "Деталь: " << dlerror() << endl;
            return false;
        }

        CipherPlugin plugin;
        plugin.handle = handle;

        plugin.getCipherName = (GetCipherName_t) dlsym(handle, "GetCipherName");
        plugin.validateKey = (ValidateKey_t) dlsym(handle, "ValidateKey");
        plugin.encryptData = (EncryptData_t) dlsym(handle, "EncryptData");
        plugin.decryptData = (DecryptData_t) dlsym(handle, "DecryptData");

        if (!plugin.getCipherName || !plugin.validateKey ||
            !plugin.encryptData || !plugin.decryptData) {
            cerr << "Библиотека не содержит все необходимые функции!" << endl;
            dlclose(handle);
            return false;
        }

        plugin.name = plugin.getCipherName();
        loadedCiphers.push_back(plugin);

        cout << "Загружен модуль >> " << plugin.name
             << " (" << getUserNameForCipher(plugin.name) << ")" << endl;
        return true;

    } catch (const exception& e) {
        cerr << "Неожиданная ошибка >> " << e.what() << endl;
        return false;
    }
}

void UnloadAllCiphers() {
    for (auto& plugin : loadedCiphers) {
        if (plugin.handle) {
            dlclose(plugin.handle);
            plugin.handle = nullptr;
        }
    }
    loadedCiphers.clear();
    cout << "Все модули выгружены" << endl;
}

void ProcessTextEncryption() {
    if (loadedCiphers.empty()) {
        cerr << "Нет загруженных шифров!" << endl;
        return;
    }

    cout << "\nДоступные алгоритмы:" << endl;
    for (size_t i = 0; i < loadedCiphers.size(); i++) {
        cout << (i + 1) << ". " << getUserNameForCipher(loadedCiphers[i].name) << endl;
    }

    int choice = getIntegerInput("Выберите алгоритм: ", 1, loadedCiphers.size());
    CipherPlugin &cipher = loadedCiphers[choice - 1];

    bool encrypt = getChoice("Операция:\n1. Шифровать\n2. Дешифровать\nВыбор: ", {1, 2}) == 1;

    string key = getLine("Введите ключ: ", false);

    if (!cipher.validateKey(key)) {
        cerr << "Некорректный ключ!" << endl;
        return;
    }

    string text = getLine("Введите текст: ", false);
    vector<uint8_t> input(text.begin(), text.end());
    vector<uint8_t> output(input.size());

    if (encrypt) {
        cipher.encryptData(input.data(), output.data(), input.size(), key);

        cout << "Результат (hex): ";
        for (uint8_t byte : output) {
            cout << hex << setw(2) << setfill('0') << (int)byte << " ";
        }
        cout << dec << endl;
    } else {
        cipher.decryptData(input.data(), output.data(), input.size(), key);

        string result(output.begin(), output.end());
        cout << "Результат: " << result << endl;
    }
}

void ProcessFileEncryption() {
    if (loadedCiphers.empty()) {
        cerr << "Нет загруженных шифров!" << endl;
        return;
    }

    cout << "\nДоступные алгоритмы:" << endl;
    for (size_t i = 0; i < loadedCiphers.size(); i++) {
        cout << (i + 1) << ". " << getUserNameForCipher(loadedCiphers[i].name) << endl;
    }

    int choice = getIntegerInput("Выберите алгоритм: ", 1, loadedCiphers.size());
    CipherPlugin &cipher = loadedCiphers[choice - 1];

    bool encrypt = getChoice("Операция:\n1. Шифровать\n2. Дешифровать\nВыбор: ", {1, 2}) == 1;

    string key = getLine("Введите ключ: ", false);
    if (!cipher.validateKey(key)) {
        cerr << "Некорректный ключ!" << endl;
        return;
    }

    string inputFile = getLine("Входной файл: ", false);
    string outputFile = getLine("Выходной файл: ", false);

    try {
        vector<unsigned char> inputDataUC = readFile(inputFile);
        vector<uint8_t> inputData(inputDataUC.begin(), inputDataUC.end());
        vector<uint8_t> outputData(inputData.size());

        if (encrypt) {
            cipher.encryptData(inputData.data(), outputData.data(), inputData.size(), key);
        } else {
            cipher.decryptData(inputData.data(), outputData.data(), inputData.size(), key);
        }

        vector<unsigned char> outputDataUC(outputData.begin(), outputData.end());
        writeFile(outputFile, outputDataUC);
        cout << "Файл обработан: " << outputFile << endl;

        createLogFile(outputFile, getUserNameForCipher(cipher.name),
                      encrypt ? "cipher" : "decipher",
                      key, inputFile, outputFile);

    } catch (const exception& e) {
        cerr << "Ошибка обработки файла >> " << e.what() << endl;
    }
}

void ShowKeyGenerator() {
    if (loadedCiphers.empty()) {
        cerr << "Нет загруженных шифров!" << endl;
        return;
    }

    cout << "\nДоступные алгоритмы:" << endl;
    for (size_t i = 0; i < loadedCiphers.size(); i++) {
        cout << (i + 1) << ". " << getUserNameForCipher(loadedCiphers[i].name) << endl;
    }

    string generatedKey = generateRandomKey(16);
    cout << "Сгенерированный ключ: " << generatedKey << endl;
}


=== Encryption_Algorithm_RGR/src/vigenere/vigenere_wrapper.cpp ===
#include "vigenere/vigenere_cipher.h"
#include "api.h"
#include <cstring>

extern "C" {
    
    const char* GetCipherName() {
        return "Vigenere Cipher";
    }
    
    bool ValidateKey(const std::string &key) {
        return !key.empty() && key.length() <= 256;
    }
    
    void EncryptData(const uint8_t *inputData, uint8_t *outputData, 
                    size_t dataSize, const std::string &key) {
        if (!inputData || !outputData || dataSize == 0) return;
        
        std::vector<unsigned char> input(inputData, inputData + dataSize);
        std::vector<unsigned char> encrypted = vigenereEncrypt(input, key);
        
        std::memcpy(outputData, encrypted.data(), encrypted.size());
    }
    
    void DecryptData(const uint8_t *inputData, uint8_t *outputData, 
                    size_t dataSize, const std::string &key) {
        if (!inputData || !outputData || dataSize == 0) return;
        
        std::vector<unsigned char> input(inputData, inputData + dataSize);
        std::vector<unsigned char> decrypted = vigenereDecrypt(input, key);
        
        std::memcpy(outputData, decrypted.data(), decrypted.size());
    }
}


=== Encryption_Algorithm_RGR/src/vigenere/vigenere_cipher_interface.cpp ===
#include "vigenere/vigenere_cipher_interface.h"
#include "vigenere/vigenere_cipher.h"
#include "utils.h"
#include <iostream>
#include <sstream>
#include <iomanip>
#include <filesystem>
#include <algorithm>
#include <locale>
#include <clocale>

using namespace std;
namespace fs = filesystem;

void printResult(const vector<unsigned char>& data, bool isEncrypted) {
    if (isEncrypted) {
        cout << "Результат (hex): ";
        for (unsigned char c : data) {
            cout << hex << setw(2) << setfill('0') << static_cast<int>(c) << " ";
        }
        cout << dec << endl << "Символьное представление: ";
        
        // Для зашифрованных данных - только ASCII
        for (unsigned char c : data) {
            if (c >= 32 && c < 127) {
                cout << c;
            } else {
                cout << ".";
            }
        }
    } else {
        // Для расшифрованных - выводим как текст
        cout << "Расшифрованный текст: ";
        string text(data.begin(), data.end());
        cout << text;
    }
    cout << endl;
}

void runVigenereCipher() {
    setlocale(LC_ALL, "ru_RU.UTF-8");
    locale::global(locale("ru_RU.UTF-8"));

    try {
        cout << "=== Шифр Виженера ===" << endl;

        bool encrypt = getChoice("Выберите:\n1. Шифровать\n2. Дешифровать\nВаш выбор: ", {1, 2}) == 1;

        string key;
        int keyChoice = getChoice("Ключ:\n1. Ввести\n2. Сгенерировать\nВаш выбор: ", {1, 2});
        
        if (keyChoice == 2) {
            int len = getIntegerInput("Длина ключа (от 1 до 256): ", 1, 256);
            key = generateVigenereKey(len);
            cout << "Сгенерированный ключ (hex): ";
            for (unsigned char c : key) {
                cout << hex << setw(2) << setfill('0') << static_cast<int>(c);
            }
            cout << dec << endl;
        } else {
            // ДОБАВЛЕНО: Выбор формата ввода ключа
            int keyFormat = getChoice("Формат ключа:\n1. Текст\n2. Hex\nВаш выбор: ", {1, 2});
            
            if (keyFormat == 1) {
                key = getLine("Введите ключ: ", false);
                cout << "Ключ принят как текст" << endl;
            } else {
                string hexKey = getLine("Введите ключ в hex: ", false);
                vector<unsigned char> keyBytes = hexToBytes(hexKey);
                key = string(keyBytes.begin(), keyBytes.end());
                cout << "Ключ принят как hex-последовательность" << endl;
            }
        }

        int sourceChoice = getChoice("Данные:\n1. Ввести текст\n2. Работа с файлом\nВаш выбор: ", {1, 2});

        if (sourceChoice == 1) {
            // Обработка текстового ввода
            if (encrypt) {
                string text = getLine("Введите текст: ", false);
                vector<unsigned char> inputData(text.begin(), text.end());
                vector<unsigned char> outputData = vigenereEncrypt(inputData, key);
                printResult(outputData, true);
            } else {
                string hexInput = getLine("Введите hex: ", false);
                vector<unsigned char> inputData = hexToBytes(hexInput);
                vector<unsigned char> outputData = vigenereDecrypt(inputData, key);
                printResult(outputData, false);
            }
        } else {
            // Обработка файлов
            cout << "\nФайлы в текущей директории:\n";
            vector<string> files = getFilesInCurrentDir();
            for (const auto& file : files) {
                cout << "- " << file << endl;
            }
            cout << endl;

            string inputFile = getLine("Введите имя файла или полный путь: ", false);

            // ПРЕДУПРЕЖДЕНИЕ ДЛЯ ИЗОБРАЖЕНИЙ
            if (encrypt && isImageFile(inputFile)) {
                cout << "⚠️  ВНИМАНИЕ: Выбран файл изображения.\n";
                cout << "Шифрование может сделать изображение непригодным для просмотра.\n";
                int continueChoice = getChoice("Продолжить? (1-Да, 2-Нет): ", {1, 2});
                if (continueChoice != 1) {
                    cout << "Операция отменена.\n";
                    return;
                }
            }

            string outputPath = getLine("Куда сохранить результат? (оставьте пустым для сохранения рядом): ", false);

            vector<unsigned char> inputData = readFile(inputFile);
            vector<unsigned char> outputData;

            if (encrypt) {
                outputData = vigenereEncrypt(inputData, key);
                
                if (outputPath.empty()) {
                    fs::path p = fs::path(inputFile);
                    outputPath = p.stem().string() + "_encrypted" + p.extension().string();
                }
            } else {
                outputData = vigenereDecrypt(inputData, key);
                
                if (outputPath.empty()) {
                    fs::path p = fs::path(inputFile);
                    outputPath = p.stem().string() + "_decrypted" + p.extension().string();
                }
            }

            writeFile(outputPath, outputData);
            cout << "Файл будет сохранен по пути: " << fs::absolute(outputPath) << endl;

            // Вывод результата на экран
            cout << "\nРезультат (первые 16 байт в hex): ";
            for (size_t i = 0; i < min(outputData.size(), static_cast<size_t>(16)); ++i) {
                cout << hex << setw(2) << setfill('0') << static_cast<int>(outputData[i]) << " ";
            }
            cout << dec << endl;

            // Создание лог-файла
            createLogFile(outputPath, "Vigenere", encrypt ? "cipher" : "decipher", 
                         key, inputFile, outputPath);
        }
    } catch (const exception& e) {
        cerr << "Ошибка: " << e.what() << endl;
    }
    
    cin.clear();
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
}

=== Encryption_Algorithm_RGR/src/vigenere/vigenere_cipher.cpp ===
#include "vigenere/vigenere_cipher.h"
#include "utils.h"
#include <stdexcept>
#include <algorithm>

using namespace std;

vector<unsigned char> vigenereEncrypt(const vector<unsigned char>& data, const string& key) {
    validateKey(key);
    if (data.empty()) return {};

    vector<unsigned char> result;
    result.reserve(data.size());
    size_t key_index = 0;

    for (unsigned char c : data) {
        unsigned char k = static_cast<unsigned char>(key[key_index % key.size()]);
        result.push_back((c + k) % 256);
        key_index++;
    }

    return result;
}

vector<unsigned char> vigenereDecrypt(const vector<unsigned char>& data, const string& key) {
    validateKey(key);
    if (data.empty()) return {};

    vector<unsigned char> result;
    result.reserve(data.size());
    size_t key_index = 0;

    for (unsigned char c : data) {
        unsigned char k = static_cast<unsigned char>(key[key_index % key.size()]);
        result.push_back((c - k + 256) % 256);
        key_index++;
    }

    return result;
}

string generateVigenereKey(int length) {
    if (length <= 0 || length > 256) {
        throw invalid_argument("Длина ключа должна быть от 1 до 256");
    }
    
    string key;
    key.reserve(length);
    
    for (int i = 0; i < length; ++i) {
        key.push_back(static_cast<char>(randomInt(0, 255)));
    }
    
    return key;
}

=== Encryption_Algorithm_RGR/src/great/great_cipher_interface.cpp ===
#include "great/great_cipher_interface.h"
#include "great/great_cipher.h"
#include "utils.h"
#include <iostream>
#include <sstream>
#include <iomanip>
#include <filesystem>
#include <algorithm>

using namespace std;
namespace fs = filesystem;

void printGreatResult(const vector<uint8_t>& data, bool isEncrypted, bool isFile = false) {
    if (isFile) {
        cout << "Результат (первые 16 байт в hex): ";
        for (size_t i = 0; i < min(data.size(), static_cast<size_t>(16)); ++i) {
            cout << hex << setw(2) << setfill('0') << static_cast<int>(data[i]) << " ";
        }
        cout << dec << endl;
    } else {
        if (isEncrypted) {
            cout << "Результат (hex): ";
            for (uint8_t byte : data) {
                cout << hex << setw(2) << setfill('0') << static_cast<int>(byte) << " ";
            }
            cout << dec << endl << "Символьное представление: ";
            
            string text(data.begin(), data.end());
            for (char c : text) {
                if (c >= 32 && c < 127) {
                    cout << c;
                } else {
                    cout << ".";
                }
            }
            cout << endl;
        } else {
            // ТОЛЬКО для дешифрования - показываем только текст
            string resultText(data.begin(), data.end());
            cout << "Расшифрованный текст: " << resultText << endl;
        }
    }
}

void runGreatCipher() {
    try {
        cout << "=== Великий шифр (Louis XIV) ===" << endl;
        cout << "Исторический шифр с системой омофонов" << endl;

        bool encrypt = getChoice("Выберите:\n1. Шифровать\n2. Дешифровать\nВаш выбор: ", {1, 2}) == 1;

        // ВВОД КЛЮЧА
        string key;
        int keyChoice = getChoice("Ключ:\n1. Ввести\n2. Сгенерировать\nВаш выбор: ", {1, 2});
        
        if (keyChoice == 2) {
            int length = getIntegerInput("Длина ключа (1-20): ", 1, 20);
            key = generateRandomKey(length);
            cout << "Сгенерированный ключ: " << key << endl;
        } else {
            key = getLine("Введите ключ: ", false);
            if (key.empty()) {
                cout << "Ошибка: Ключ не может быть пустым" << endl;
                return;
            }
        }

        int sourceChoice = getChoice("Данные:\n1. Ввести текст\n2. Работа с файлом\nВаш выбор: ", {1, 2});

        if (sourceChoice == 2) {
            // Файловая работа
            cout << "\nФайлы в текущей директории:\n";
            vector<string> files = getFilesInCurrentDir();
            for (const auto& file : files) {
                cout << "- " << file << endl;
            }
            cout << endl;

            string inputFile = getLine("Введите имя файла или полный путь: ", false);

            // ПРЕДУПРЕЖДЕНИЕ ДЛЯ ИЗОБРАЖЕНИЙ
            if (encrypt && isImageFile(inputFile)) {
                cout << "⚠️  ВНИМАНИЕ: Выбран файл изображения.\n";
                cout << "Шифрование может сделать изображение непригодным для просмотра.\n";
                int continueChoice = getChoice("Продолжить? (1-Да, 2-Нет): ", {1, 2});
                if (continueChoice != 1) {
                    cout << "Операция отменена.\n";
                    return;
                }
            }

            string outputPath = getLine("Куда сохранить результат? (оставьте пустым для сохранения рядом): ", false);

            vector<unsigned char> inputData = readFile(inputFile);
            vector<uint8_t> inputBytes(inputData.begin(), inputData.end());
            
            vector<uint8_t> outputBytes;
            if (encrypt) {
                outputBytes = GreatCipher::processBytes(inputBytes, key, true);
            } else {
                outputBytes = GreatCipher::processBytes(inputBytes, key, false);
            }

            vector<unsigned char> outputData(outputBytes.begin(), outputBytes.end());

            if (outputPath.empty()) {
                fs::path p = fs::path(inputFile);
                outputPath = p.stem().string() + (encrypt ? "_great_enc" : "_great_dec") + p.extension().string();
            }

            writeFile(outputPath, outputData);
            cout << "Файл будет сохранен по пути: " << fs::absolute(outputPath) << endl;
            printGreatResult(outputBytes, encrypt, true);
            
            createLogFile(outputPath, "Great Cipher (Louis XIV)", encrypt ? "cipher" : "decipher", 
                         key, inputFile, outputPath);
        } else {
            // Текстовый ввод
            if (encrypt) {
                string text = getLine("Введите текст: ", false);
                string result = GreatCipher::processText(text, key, true);
                vector<uint8_t> resultBytes(result.begin(), result.end());
                printGreatResult(resultBytes, true);
            } else {
                string hexInput = getLine("Введите hex: ", false);
                vector<unsigned char> data = hexToBytes(hexInput);
                vector<uint8_t> bytes(data.begin(), data.end());
                vector<uint8_t> resultBytes = GreatCipher::processBytes(bytes, key, false);
                printGreatResult(resultBytes, false);
            }
        }
    } catch (const exception& e) {
        cerr << "Ошибка: " << e.what() << endl;
    }
    
    cin.clear();
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
}

=== Encryption_Algorithm_RGR/src/great/great_cipher.cpp ===
#include "great/great_cipher.h"
#include "utils.h"
#include <algorithm>
#include <functional>
#include <random>

using namespace std;

// Хеш-функция для преобразования строки в seed
uint32_t stringToSeed(const string& key) {
    hash<string> hasher;
    return static_cast<uint32_t>(hasher(key));
}

GreatCipher::GreatCipher(uint32_t seed) : keySeed(seed) {
    createTables();
}

GreatCipher::GreatCipher(const string& key) : keySeed(stringToSeed(key)) {
    createTables();
}

void GreatCipher::createTables() {
    // Используем keySeed для инициализации генератора
    mt19937 generator(keySeed);
    uniform_int_distribution<int> dist(100, 65535);
    
    encryptionTable.clear();
    decryptionTable.clear();
    homophoneSequence.clear();
    
    // Создаем таблицы омофонов с использованием ключа
    for (int symbol = 0; symbol < 256; symbol++) {
        vector<uint16_t> codes;
        int numHomophones = 2 + (symbol % 5); // 2-6 омофонов на символ
        
        for (int i = 0; i < numHomophones; i++) {
            uint16_t code = dist(generator);
            codes.push_back(code);
            
            encryptionTable[code].push_back(static_cast<uint8_t>(symbol));
        }
        
        // Перемешиваем коды для этого символа для случайности
        shuffle(codes.begin(), codes.end(), generator);
        decryptionTable[static_cast<uint8_t>(symbol)] = codes;
    }
    
    // Создаем последовательность для выбора омофонов
    for (int i = 0; i < 1000; i++) {
        homophoneSequence.push_back(dist(generator));
    }
}

uint16_t GreatCipher::getNextCode(size_t position) {
    return homophoneSequence[position % homophoneSequence.size()];
}

vector<uint8_t> GreatCipher::encrypt(const vector<uint8_t>& data) {
    if (data.empty()) return {};
    
    vector<uint8_t> encrypted;
    
    for (size_t i = 0; i < data.size(); i++) {
        uint8_t symbol = data[i];
        
        if (decryptionTable.find(symbol) != decryptionTable.end()) {
            // Выбираем случайный омофон для этого символа
            const auto& codes = decryptionTable[symbol];
            size_t index = (i + getNextCode(i)) % codes.size();
            uint16_t code = codes[index];
            
            // Разбиваем 16-битный код на 2 байта
            encrypted.push_back(static_cast<uint8_t>(code >> 8));
            encrypted.push_back(static_cast<uint8_t>(code & 0xFF));
        } else {
            // Если символа нет в таблице, используем прямое преобразование
            encrypted.push_back(symbol);
            encrypted.push_back(0);
        }
    }
    
    return encrypted;
}

vector<uint8_t> GreatCipher::decrypt(const vector<uint8_t>& data) {
    if (data.empty() || data.size() % 2 != 0) return {};
    
    vector<uint8_t> decrypted;
    
    for (size_t i = 0; i < data.size(); i += 2) {
        uint16_t code = (static_cast<uint16_t>(data[i]) << 8) | data[i + 1];
        
        if (encryptionTable.find(code) != encryptionTable.end()) {
            // Выбираем первый вариант декодирования (омофоны)
            const auto& symbols = encryptionTable[code];
            decrypted.push_back(symbols[0]);
        } else {
            // Прямое преобразование для неизвестных кодов
            decrypted.push_back(data[i]);
        }
    }
    
    return decrypted;
}

string GreatCipher::encryptText(const string& text) {
    vector<uint8_t> inputBytes(text.begin(), text.end());
    vector<uint8_t> encryptedBytes = encrypt(inputBytes);
    return string(encryptedBytes.begin(), encryptedBytes.end());
}

string GreatCipher::decryptText(const string& text) {
    vector<uint8_t> inputBytes(text.begin(), text.end());
    vector<uint8_t> decryptedBytes = decrypt(inputBytes);
    return string(decryptedBytes.begin(), decryptedBytes.end());
}

vector<uint8_t> GreatCipher::processBytes(const vector<uint8_t>& data, const string& key, bool encrypt) {
    GreatCipher cipher(key);
    
    if (encrypt) {
        return cipher.encrypt(data);
    } else {
        return cipher.decrypt(data);
    }
}

string GreatCipher::processText(const string& text, const string& key, bool encrypt) {
    GreatCipher cipher(key);
    
    if (encrypt) {
        return cipher.encryptText(text);
    } else {
        return cipher.decryptText(text);
    }
}

=== Encryption_Algorithm_RGR/src/great/great_wrapper.cpp ===
#include "great/great_cipher.h"
#include "api.h"
#include <cstring>

extern "C" {
    
    const char* GetCipherName() {
        return "Great Cipher (Louis XIV)";
    }
    
    bool ValidateKey(const std::string &key) {
        return !key.empty() && key.length() <= 256;
    }
    
    void EncryptData(const uint8_t *inputData, uint8_t *outputData, 
                    size_t dataSize, const std::string &key) {
        if (!inputData || !outputData || dataSize == 0) return;
        
        std::vector<uint8_t> input(inputData, inputData + dataSize);
        GreatCipher cipher(key);
        std::vector<uint8_t> encrypted = cipher.encrypt(input);
        
        std::memcpy(outputData, encrypted.data(), encrypted.size());
    }
    
    void DecryptData(const uint8_t *inputData, uint8_t *outputData, 
                    size_t dataSize, const std::string &key) {
        if (!inputData || !outputData || dataSize == 0) return;
        
        std::vector<uint8_t> input(inputData, inputData + dataSize);
        GreatCipher cipher(key);
        std::vector<uint8_t> decrypted = cipher.decrypt(input);
        
        std::memcpy(outputData, decrypted.data(), decrypted.size());
    }
}


=== Encryption_Algorithm_RGR/src/utils.cpp ===
#include "utils.h"
#include <iostream>
#include <limits>
#include <fstream>
#include <random>
#include <termios.h>
#include <unistd.h>
#include <cctype>
#include <locale>
#include <iomanip>
#include <sstream>
#include <ctime>
#include <algorithm>
#include <codecvt>

using namespace std;

void clearInputBuffer() {
    cin.clear();
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
}

int getChoice(const string& prompt, const initializer_list<int>& options) {
    int choice;
    while (true) {
        cout << prompt;
        if (!(cin >> choice)) {
            cout << "Ошибка: Некорректный ввод. Пожалуйста, введите число.\n";
            clearInputBuffer();
            continue;
        }

        bool valid = false;
        for (int option : options) {
            if (choice == option) {
                valid = true;
                break;
            }
        }

        if (!valid) {
            cout << "Ошибка: Недопустимый выбор. Пожалуйста, выберите из предложенных вариантов.\n";
            clearInputBuffer();
            continue;
        }

        clearInputBuffer();
        return choice;
    }
}

int getIntegerInput(const string& prompt, int min, int max) {
    int value;
    while (true) {
        cout << prompt;
        if (!(cin >> value)) {
            cout << "Ошибка: Некорректный ввод. Пожалуйста, введите число.\n";
            clearInputBuffer();
            continue;
        }

        if (value < min || value > max) {
            cout << "Ошибка: Значение должно быть между " << min << " и " << max << "\n";
            clearInputBuffer();
            continue;
        }

        clearInputBuffer();
        return value;
    }
}


string getLine(const string& prompt, bool maskInput) {
    string input;
    cout << prompt;
    cout.flush();

    if (maskInput) {
        termios oldt;
        tcgetattr(STDIN_FILENO, &oldt);
        termios newt = oldt;
        newt.c_lflag &= ~ECHO;

        if (tcsetattr(STDIN_FILENO, TCSANOW, &newt) != 0) {
            cerr << "Ошибка: Не удалось настроить терминал. Ввод будет видимым." << endl;
            getline(cin, input);
        } else {
            getline(cin, input);
            tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
            cout << endl;
        }
    } else {
        getline(cin, input);
    }
    return input;
}

bool isDigits(const string& str) {
    for (char c : str) {
        if (!isdigit(static_cast<unsigned char>(c))) {
            return false;
        }
    }
    return !str.empty();
}

void initLocale() {
    setlocale(LC_ALL, "");
    locale::global(locale(""));
    cout.imbue(locale());
}

// ================== Работа с файлами ==================

vector<unsigned char> readFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        throw runtime_error("Не удалось открыть файл для чтения: " + filename);
    }

    file.seekg(0, ios::end);
    streamsize size = file.tellg();
    file.seekg(0, ios::beg);

    vector<unsigned char> buffer(size);
    if (!file.read(reinterpret_cast<char*>(buffer.data()), size)) {
        throw runtime_error("Ошибка чтения файла: " + filename);
    }
    
    return buffer;
}

void writeFile(const string& filename, const vector<unsigned char>& data) {
    ofstream file(filename, ios::binary);
    if (!file) {
        throw runtime_error("Не удалось открыть файл для записи: " + filename);
    }
    file.write(reinterpret_cast<const char*>(data.data()), data.size());
}

vector<string> getFilesInCurrentDir() {
    vector<string> files;
    try {
        for (const auto& entry : fs::directory_iterator(fs::current_path())) {
            if (entry.is_regular_file()) {
                string filename = entry.path().filename().string();
                if (isImageFile(filename)) {
                    files.push_back(filename + " 🖼️");
                } else {
                    files.push_back(filename);
                }
            }
        }
    } catch (const exception& e) {
        cerr << "Ошибка чтения директории: " << e.what() << endl;
    }
    return files;
}

// ================== Определение типа файла ==================

bool isImageFile(const std::string& filename) {
    static const vector<string> imageExtensions = {
        ".jpg", ".jpeg", ".png", ".bmp", ".gif", ".tiff", ".tif", 
        ".webp", ".raw", ".ico", ".svg", ".psd"
    };
    
    string ext = getFileExtension(filename);
    transform(ext.begin(), ext.end(), ext.begin(), ::tolower);
    
    return find(imageExtensions.begin(), imageExtensions.end(), ext) != imageExtensions.end();
}

std::string getFileExtension(const std::string& filename) {
    fs::path p(filename);
    return p.extension().string();
}

std::string getFileType(const std::string& filename) {
    if (isImageFile(filename)) {
        return "Изображение";
    }
    
    string ext = getFileExtension(filename);
    transform(ext.begin(), ext.end(), ext.begin(), ::tolower);
    
    // Проверки для других типов файлов
    static const vector<string> textExtensions = {
        ".txt", ".doc", ".docx", ".pdf", ".rtf", ".odt", 
        ".tex", ".md", ".log", ".csv"
    };
    static const vector<string> archiveExtensions = {
        ".zip", ".rar", ".7z", ".tar", ".gz", ".bz2", 
        ".xz", ".tgz", ".tbz2"
    };
    static const vector<string> audioExtensions = {
        ".mp3", ".wav", ".flac", ".aac", ".ogg", ".wma", 
        ".m4a", ".opus"
    };
    static const vector<string> videoExtensions = {
        ".mp4", ".avi", ".mkv", ".mov", ".wmv", ".flv", 
        ".webm", ".m4v", ".3gp"
    };
    static const vector<string> codeExtensions = {
        ".cpp", ".c", ".h", ".hpp", ".java", ".py", ".js", 
        ".html", ".css", ".php", ".xml", ".json"
    };
    static const vector<string> execExtensions = {
        ".exe", ".bin", ".app", ".deb", ".rpm", ".msi"
    };
    
    if (find(textExtensions.begin(), textExtensions.end(), ext) != textExtensions.end()) {
        return "Текстовый файл";
    } else if (find(archiveExtensions.begin(), archiveExtensions.end(), ext) != archiveExtensions.end()) {
        return "Архив";
    } else if (find(audioExtensions.begin(), audioExtensions.end(), ext) != audioExtensions.end()) {
        return "Аудио файл";
    } else if (find(videoExtensions.begin(), videoExtensions.end(), ext) != videoExtensions.end()) {
        return "Видео файл";
    } else if (find(codeExtensions.begin(), codeExtensions.end(), ext) != codeExtensions.end()) {
        return "Исходный код";
    } else if (find(execExtensions.begin(), execExtensions.end(), ext) != execExtensions.end()) {
        return "Исполняемый файл";
    } else if (ext.empty()) {
        return "Файл без расширения";
    } else {
        return "Другой файл";
    }
}

void createLogFile(const string& outputPath, const string& cipherName,
                 const string& operation, const string& key,
                 const string& inputFile, const string& outputFile) {
    try {
        fs::path logPath = fs::path(outputPath).parent_path() / 
                          (fs::path(outputPath).stem().string() + 
                          "_" + operation + "_log.txt");
        
        ofstream log(logPath);
        auto now = chrono::system_clock::now();
        auto now_time = chrono::system_clock::to_time_t(now);
        
        log << "=== Лог операции ===" << "\n"
            << "Тип операции: " << (operation == "cipher" ? "Шифрование" : "Дешифрование") << "\n"
            << "Алгоритм: " << cipherName << "\n"
            << "Входной файл: " << inputFile << "\n"
            << "Тип файла: " << getFileType(inputFile) << "\n"
            << "Ключ: " << key << "\n"
            << "Выходной файл: " << outputFile << "\n"
            << "Время выполнения: " << put_time(localtime(&now_time), "%Y-%m-%d %H:%M:%S") << "\n";
    } catch (const exception& e) {
        cerr << "Ошибка создания лог-файла: " << e.what() << endl;
    }
}

// ================== Генерация случайных чисел ==================

int randomInt(int min, int max) {
    static random_device rd;
    static mt19937 gen(rd());
    uniform_int_distribution<> distrib(min, max);
    return distrib(gen);
}

string generateRandomKey(int length) {
    const string chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    string key;
    
    for (int i = 0; i < length; i++) {
        key += chars[randomInt(0, chars.length() - 1)];
    }
    
    return key;
}

// ================== Вывод результатов ==================

void printHex(const vector<unsigned char>& data) {
    cout << "Результат (hex): ";
    for (unsigned char c : data) {
        cout << hex << setw(2) << setfill('0') << static_cast<int>(c) << " ";
    }
    cout << dec << endl;
}

void printTextRepresentation(const vector<unsigned char>& data) {
    cout << "Символьное представление: ";
    for (unsigned char c : data) {
        if (isprint(c)) cout << c;
        else cout << ".";
    }
    cout << endl;
}

// ================== Функции для работы с hex ==================

vector<unsigned char> hexToBytes(const string& hex) {
    vector<unsigned char> bytes;
    string hexClean = hex;
    
    hexClean.erase(remove_if(hexClean.begin(), hexClean.end(), ::isspace), hexClean.end());
    
    if (hexClean.length() % 2 != 0) {
        throw runtime_error("Hex строка должна иметь четное количество символов");
    }

    for (size_t i = 0; i < hexClean.length(); i += 2) {
        string byteString = hexClean.substr(i, 2);
        char* end;
        unsigned long byte = strtoul(byteString.c_str(), &end, 16);
        if (*end != '\0' || byte > 255) {
            throw runtime_error("Неверный hex формат");
        }
        bytes.push_back(static_cast<unsigned char>(byte));
    }
    
    return bytes;
}

void saveKeyToFile(const string& filename, const map<pair<unsigned char, unsigned char>, unsigned char>& key) {
    ofstream file(filename, ios::binary);
    if (!file) throw runtime_error("Не удалось открыть файл для записи ключа");

    for (const auto& entry : key) {
        file.write(reinterpret_cast<const char*>(&entry.first.first), sizeof(unsigned char));
        file.write(reinterpret_cast<const char*>(&entry.first.second), sizeof(unsigned char));
        file.write(reinterpret_cast<const char*>(&entry.second), sizeof(unsigned char));
    }
}

map<pair<unsigned char, unsigned char>, unsigned char> loadKeyFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) throw runtime_error("Не удалось открыть файл для чтения ключа");

    map<pair<unsigned char, unsigned char>, unsigned char> key;
    unsigned char first, second, value;

    while (file.read(reinterpret_cast<char*>(&first), sizeof(unsigned char))) {
        if (!file.read(reinterpret_cast<char*>(&second), sizeof(unsigned char))) break;
        if (!file.read(reinterpret_cast<char*>(&value), sizeof(unsigned char))) break;
        key[make_pair(first, second)] = value;
    }

    return key;
}

string bytesToHex(const vector<unsigned char>& data) {
    ostringstream oss;
    oss << hex << setfill('0');
    for (unsigned char c : data) {
        oss << setw(2) << static_cast<int>(c) << " ";
    }
    return oss.str();
}

=== Encryption_Algorithm_RGR/src/main.cpp ===
#include "utils.h"
#include "vigenere/vigenere_cipher_interface.h"
#include "great/great_cipher_interface.h"
#include "bigram/bigram_cipher_interface.h"
#include "funcs.h"
#include "cipher_plugin.h"
#include <iostream>
#include <filesystem>
#include <limits>

using namespace std;
namespace fs = filesystem;

extern vector<CipherPlugin> loadedCiphers;

struct CipherMenuItem {
    string internalName;
    string userName;
    int menuNumber;
    bool available;
};

bool hasPlugin(const string &internalName) {
    for (const auto &p : loadedCiphers) {
        if (p.name == internalName) return true;
    }
    return false;
}

bool checkPassword() {
    const string correctPassword = "securepass";
    int attemptsLeft = 3;

    while (attemptsLeft > 0) {
        cout << "Осталось попыток: " << attemptsLeft << endl;
        string password = getLine("Введите пароль: ", true);
        if (password == correctPassword) {
            cout << "Доступ разрешён!" << endl;
            return true;
        } else {
            attemptsLeft--;
            if (attemptsLeft > 0) {
                cout << "Неверный пароль. Повторите попытку." << endl;
            }
        }
    }

    cout << "Превышено количество попыток. Доступ запрещён." << endl;
    return false;
}

int main() {
    initLocale();

    cout << "Загрузка криптомодулей (.so)..." << endl;

    if (fs::exists("libs")) {
        for (const auto &entry : fs::directory_iterator("libs")) {
            if (entry.path().extension() == ".so") {
                if (!LoadCipher(entry.path().string())) {
                    string libName = entry.path().filename().string();
                    cout << "Модуль из библиотеки " << libName
                         << " не был загружен и будет недоступен для использования." << endl;
                }
            }
        }
    } else {
        cerr << "Папка libs/ не найдена." << endl;
    }

    cout << "Загруженные криптомодули (.so):" << endl;
    if (loadedCiphers.empty()) {
        cout << "  (нет загруженных модулей, используются встроенные реализации)" << endl;
    } else {
        for (const auto &plugin : loadedCiphers) {
            cout << "  - " << plugin.name
                 << " (" << getUserNameForCipher(plugin.name) << ")" << endl;
        }
    }
    cout << endl;

    if (!checkPassword()) {
        UnloadAllCiphers();
        return 1;
    }

    vector<CipherMenuItem> menuItems = {
        { "Vigenere Cipher",           "Шифр Виженера",             1, true },
        { "Great Cipher (Louis XIV)",  "Великий шифр (Louis XIV)",  2, true },
        { "Bigram Cipher (Tritemius)", "Биграммный шифр Тритемия",  3, true }
    };

    bool running = true;
    while (running) {
        cout << "Выберите шифр:" << endl;
        for (auto &item : menuItems) {
            bool pluginPresent = hasPlugin(item.internalName);
            item.available = pluginPresent;
            cout << item.menuNumber << ". " << item.userName;
            if (!pluginPresent) {
                cout << " [НЕДОСТУПЕН: модуль не найден]";
            }
            cout << endl;
        }
        cout << "4. Выход" << endl;
        cout << "Ваш выбор: ";

        int choice = getIntegerInput("", 1, 4);

        if (choice == 4) {
            running = false;
        } else {
            CipherMenuItem *selected = nullptr;
            for (auto &item : menuItems) {
                if (item.menuNumber == choice) {
                    selected = &item;
                    break;
                }
            }

            if (!selected) {
                cout << "Неверный выбор." << endl;
            } else if (!selected->available) {
                cout << "Ошибка: модуль \"" << selected->userName
                     << "\" не загружен. Шифрование данным алгоритмом временно недоступно из-за технического сбоя." << endl;
            } else {
                if (choice == 1) {
                    runVigenereCipher();
                } else if (choice == 2) {
                    runGreatCipher();
                } else if (choice == 3) {
                    runBigramCipher();
                }
            }
        }

        if (running) {
            cout << "\n\nНажмите Enter для продолжения...";
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }
    }

    UnloadAllCiphers();
    return 0;
}


=== Encryption_Algorithm_RGR/create_launcher.sh ===
#!/bin/bash

PROJECT_DIR="/home/salero/Encryption_Algorithm_RGR"
EXECUTABLE="$PROJECT_DIR/bin/Encryption_Algorithm_RGR"

echo "=== Создаю глобальный лаунчер для Encryption_Algorithm_RGR ==="

echo "Проверяю наличие исполняемого файла..."
if [ ! -f "$EXECUTABLE" ]; then
    echo "❌ ОШИБКА: Файл $EXECUTABLE не найден!"
    echo "Сначала соберите проект: cd $PROJECT_DIR && make"
    exit 1
fi

echo "✅ Исполняемый файл найден: $EXECUTABLE"

# Создаем лаунчер в /usr/local/bin для Encryption_Algorithm_RGR
echo "Создаю глобальный лаунчер в /usr/local/bin..."
sudo bash -c "cat > '/usr/local/bin/Encryption_Algorithm_RGR' << 'EOF'
#!/bin/bash
exec \"$EXECUTABLE\" \"\$@\"
EOF"

sudo chmod +x "/usr/local/bin/Encryption_Algorithm_RGR"

# Создаем короткий алиас EAR
echo "Создаю короткий алиас EAR..."
sudo bash -c "cat > '/usr/local/bin/EAR' << 'EOF'
#!/bin/bash
exec \"$EXECUTABLE\" \"\$@\"
EOF"

sudo chmod +x "/usr/local/bin/EAR"

# Обновляем .desktop файл
echo "Обновляю .desktop файл..."
mkdir -p ~/.local/share/applications
cat > ~/.local/share/applications/Encryption_Algorithm_RGR.desktop << EOF
[Desktop Entry]
Version=1.0
Type=Application
Name=Encryption Algorithm RGR
GenericName=Encryption Tool
Comment=Program for encryption and decryption
Exec=/usr/local/bin/Encryption_Algorithm_RGR
Icon=dialog-password
Categories=Utility;Security;
Terminal=true
StartupNotify=true
EOF

update-desktop-database ~/.local/share/applications 2>/dev/null || true

echo ""
echo "=== Всё готово! ==="
echo "✅ Создан глобальный лаунчер: /usr/local/bin/Encryption_Algorithm_RGR"
echo "✅ Создан короткий алиас: /usr/local/bin/EAR"
echo "✅ Обновлен ярлык в меню приложений"
echo ""
echo "Теперь вы можете запускать программу из любой директории:"
echo "  Encryption_Algorithm_RGR"
echo "  или коротко: EAR"

